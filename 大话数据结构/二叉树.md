二叉树--是n(n>=0)个结点的有限集合,该集合或者为空集(称为空二叉树),或者由一个根结点和两棵互不相交的,分别称为根结点的左子树和右子树的二叉树组成
每个结点最多有两棵子树,左子树和右子树是有顺序的,即使只有一棵子树,也要区分左还是右,且次序不能颠倒
线性表结构可以理解为是树的一种极其特殊的表现形式
左斜树,右斜树,满二叉树,完全二叉树(按层序顺序编号)

二叉树性质:
1.在二叉树的第i层上至多有2^(i-1)个结点
2.深度为k的二叉树至多有2^k -1个结点
3.对任何一棵二叉树T,如果其终端结点数为n0,度为2的结点数为n2,则n0 = n2 + 1
4.具有n个结点的完全二叉树的深度为[log2^n]+1
5.寻找双亲为i/2等

二叉树的顺序存储结构
适用于完全二叉树,按顺序存入数组中 ABCDEFGHI
 
二叉链表
二叉树每个结点最多有两个孩子,即一个数据域和两个指针域
typedef struct BiTNode{                 //结点结构
    TElemType data;                     //结点数据
    struct BiTNode *lChild,*rChild;     //左右孩子指针
}BiTNode,*BiTree;

二叉树的遍历,是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次且仅被访问一次
1>前序遍历
先访问根节点,然后前序遍历左子树,再前序遍历右子树   ABDGHCEIF
void PreOrderTraverse(BiTree T){
    if(T==NULL){
        return;
    }
    printf("%c",T->data);   
    PreOrderTraverse(T->lCHild);//先遍历左子树
    PreOrderTraverse(T->rChild);//然后遍历右子树
}

2>中序遍历
从根结点开始,中序遍历根结点的左子树,然后访问根结点,最后中序遍历右子树    GDHBAEICF
void PreOrderTraverse(BiTree T){
    if(T==NULL){
        return;
    }
    PreOrderTraverse(T->lCHild);//先遍历左子树
    printf("%c",T->data);       
    PreOrderTraverse(T->rChild);//然后遍历右子树
}

3>后序遍历
从左到右先叶子后结点遍历左右子树,最后访问根结点    GHDBIEFCA
void PreOrderTraverse(BiTree T){
    if(T==NULL){
        return;
    }
    PreOrderTraverse(T->lCHild);//先遍历左子树
    PreOrderTraverse(T->rChild);//然后遍历右子树
    printf("%c",T->data);       
}

4>层序遍历
从根结点开始访问,从上而下逐层遍历,在同一层中,从左到右对结点逐个访问     ABCDEFGHI

建立二叉树:
将二叉树中每个结点的空指针引出一个虚结点,其值为"#",称为扩展二叉树     AB#D##C##

线索二叉树:
把空余的指针域指向前驱后继元素,指向前驱和后继的指针称为线索,加上线索的二叉链表称为线索链表,相应的二叉树就称为线索二叉树
并且除了两个左右指针域,再增加两个标识BOOL值,lTag与rTag,lTag为0时指向左孩子,为1时指向前驱,rTag为0时指向右孩子,为1时指向后继
typedef enum(Link,Thread) PointerTag;   //Link==0表示指向左右孩子指针 Thread==1表示指向前驱或后继的线索
typedef struct BiTNode{                 //结点结构
    TElemType data;                     //结点数据
    struct BiTNode *lChild,*rChild;     //左右孩子指针
    PointerTag lTag;                    //左标识
    PointerTag rTag;                    //右标识
}BiTNode,*BiTree;

树转换为二叉树:
1.加线.在所有兄弟结点之间加一条连线
2.去线.每个结点只保留与第一个孩子结点的连线,删除它与其他孩子结点之间的连线
3.第一个孩子是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子

森林转换为二叉树:
1.把每个树转换为二叉树
2.把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子

二叉树转换为树:
1.加线.将子级与孙子级的右孩子结点都作为此结点的孩子连接
2.去线.删除所有结点与其右孩子结点的连线

二叉树转换为森林:
1.把所有右孩子分离出来
2.把分离出来的二叉树转换为树

森林的前序遍历和二叉树的前序遍历结果相同,森林的后序遍历和二叉树的中序遍历结果相同

赫夫曼树
是压缩文件时用的最基本的压缩编码方法
树中一个结点到另一个结点之间的分支构成两个结点之间的路径,路径上的分支数目称为路径长度
结点的带权路径长度为从该结点到树根之间的路径长度与结点上权(值比例)的乘积
带权路径长度WPL最小的二叉树称作赫夫曼树.最优二叉树.

构造方法:
1.把各结点按照权值从小到大排列
2.取最小权值的两个结点作为新结点N1的两个子结点,新结点N1的权值为两个叶子权值得和
3.将N1替换两个结点重新排列
4.重复以上三步

传递时,构造好赫夫曼树,双方约定好赫夫曼编码规则,按照路径寻找数据
一般规定赫夫曼树的左分支代表0,右分支代表1,从根结点到叶子结点经过的路径分支组成的0和1的序列便为该结点对应字符的编码,这就是赫夫曼编码






























